@init

//* MATH *//
function round(num)
(
  floor(num + 0.5);
);


function randInt(num)
(
  round(rand(num));
);

function phase(elapsed, period) local(quotient, return) // phase(12, 8) = .5
(
  period &&
  (
    elapsed < period ? (return = elapsed / period) :
    (
      quotient = elapsed / period;
      // decimal = quotient - quotient<<0
      return = (quotient - quotient<<0) * period;
    );
  );
  return;
);

function mask(n)
(
  pow(2, n)-1;
);

// foo.readBits(6, 3) will read bits 7 thru 9 as if they were their own 3-bit integer
function readBits(offset, nBits)
(
  // foo = 1101111111
  // shifted right 6 bits = 1101
  // 1101 masked by 111 = 0101 = 5
  (this >> offset) & mask(nBits);
);

// foo.writeBits(6, 3, 2) will write the number 2 into bits 7 thru 9
// (num must fit in numBits else good luck using this as intended)
function writeBits(offset, nBits, num)
(
  // subtract whatever value is in those bits
  // 1XXX111111 -= (XXX << 6) = 1000111111
  this -= this.readBits(offset, nBits) << offset;
  // add num back into that n bit hole
  // 1000111111 + (2 << 6) = 1010111111
  this += num << offset;
  // -> foo.readBits(3, 6) = 010 = 2
);


// * ARRAYS *//

//tenSizeArray.arrayInit(10); 
function arrayInit(size) local (index)
(
  index = _nextArrayIdx; // _nextArrayIdx will be globally initialized at 0 on first call;
  _nextArrayIdx = index + size; // set up index for next call
  this = index;
  this.size = size;
  this.length = 0;
);

// tenSizeArray.push(foo)
function push(value)
(
  this.length < this.size && (
    this[this.length] = value;
    this.length += 1;
  );
);

// tenSizeArray.pop()
function pop() local (return)
(
  this.length > 0 && (
    this.length -=1;
    return = this[this.length];
  );
  return; // ðŸ˜’ local vars persist, so popping from an empty array will likely produce spurious values.
);        // there's no return value we could use to reliably indicate "was empty" so we won't bother reassigning.

function find(value) local (return, i)
(
  return = -1;
  i = 0;
  while ((return == -1) && (i < this.length))
  (
    value == this[i] && return = i;
    i += 1;
  );
  return; // nb. value may exist at more than 1 index, this will only return the first.
);

//* MIDI *//

// wrap midirecv and interpret values
// usage: while(msg.recv()) (msg.send())
function recv() local(received)
(
  //capture return value of midirecv and scope its args
  received = midirecv(m0, m1, m2, m3);
  received ? (
    this.offset = m0;
    // m1 = status byte, some 8 bit number;
    // shift away lowest 4 bits: 1111???? -> 1111
    this.statusHi = m1 >> 4;
    // mask top 4 bits: ????1010 & 00001111 -> 00001010
    this.statusLo = m1 & $~4;
    this.data1 = m2;
    this.data2 = m3;
  );
  // return 1 or 0 for while() evaluation;
  received;
);


function send()
(
  midisend(
    this.offset,
    // reconstruct status by shifting high bits to the left
    // 1111 -> 11110000
    ((this.statusHi << 4) + this.statusLo),
    this.data1,
    this.data2
  );
);

function sendWithOffset(offset)
(
  midisend(
    offset,
    ((this.statusHi << 4) + this.statusLo),
    this.data1,
    this.data2
  )
);

function isNoteOn()
(
  this.statusHi == 9;
);


function isNoteOff()
(
  this.statusHi == 8;
);


function note()
(
  this.data1;
);


function isCC()
(
  this.statusHi == 11;
);

// usage: msg.recv(),
// x = msg.toBits() -> now x is a number you can store in an array or whatever
function toBits()
(
  this.statusHi << 18 +
  this.statusLo << 14 +
  this.data1 << 7 +
  this.data2;
);
// x.parseBits() -> x is still a number but now has msg properties as well
// x.send();
function parseBits()
(
  this.statusHi = this.readBits(18, 4);
  this.statusLo = this.readBits(14, 4);
  this.data1 = this.readBits(7, 7);
  this.data2 = this.readBits(0, 7);
);
// ^^ nb. you can mutate x.foo then call x = x.toBits() again if need be


//* TIME *//

function samplesPerBar() // nb. may be non-integer
(
  // ts_num ts_denoms in a bar (4 quarter notes)
  // tempo ts_denoms in a minute (120 quarter notes)
  // duration of 1 bar in minutes = ts_num / tempo -> 4/120 = 0.0333...
  // duration of 1 bar in seconds = 60 * ts_num / tempo -> 4*60/120 = 2
  // duration of 1 bar in samples = srate * 60 * ts_num / tempo) -> 48000 * 2
  srate * ts_num * 60 / tempo;
);


//* CLOCK *//

// // global setup
// function initTime()
// (
//   _tInit = time_precise();
// );

// // clock methods
// function initClock()
// (
//   !_tInit && initTime();
//   this.t0 = _tInit;
//   this.prevPhase = 1; // ensure rollover on first tick
// );

function setPeriodSeconds(seconds)
(
  this.period = seconds * srate; // ðŸ‘€ may be non-integer
);

function setPeriodBars(bars) // 1/16, 1.5 etc
(
  // seconds per beat = 60 / tempo
  // seconds per bar = beats per measure * seconds per beat
  this.setPeriodSeconds(bars * ts_denom * 60 / tempo);
);

function getPhase()
(
  phase(this.scount, this.period);
);

// call in @block, accounts for periods of non-integer sample duration.
function c_block() 
(
  this.scount >= this.period &&
  (
    this.scount -= this.period;
    this.ticked = 1;
  );
);

// call in @sample, will return 1 on tick.
function tick()
(
  this.scount += 1;
  this.ticked && (
    this.ticked = 0;
    1;
  );
);

// clock.setPhase(0-1)
// clock.getPhase() // 0-1
// clock.setPeriodSeconds(sec)
// clock.getPeriod() // sec
// clock.setPeriodBars(n)
// clock.getPeriodInBars() // n
// clock.pause() 
// clock.resume()
// clock.setRate(hz)
// clock.getRate() //hz
// //
