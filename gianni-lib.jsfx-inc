@init

//* MATH *//
function round(num)
(
  floor(num + 0.5);
);


function randInt(num)
(
  round(rand(num));
);


function mask(n)
(
  pow(2, n)-1;
);

// foo.readBits(6, 3) will read bits 7 thru 9 as if they were their own 3-bit integer
function readBits(offset, nBits)
(
  // foo = 1101111111
  // shifted right 6 bits = 1101
  // 1101 masked by 111 = 0101 -> 5
  (this >> offset) & mask(nBits);
);

// foo.writeBits(6, 3, 2) will write the number 2 into bits 7 thru 9
// (num must fit in numBits else good luck using this as intended)
function writeBits(offset, nBits, num)
(
  // subtract whatever value is in those bits
  // foo = 1111111111 - ([bits 789] << 6) = 1000111111
  this -= this.readBits(offset, nBits) << offset;
  // add num back into that n bit hole
  // foo = 1000111111 + (10 << 6) = 1010111111
  this += num << offset;
  // foo.readBits(3, 6) = 010 = 2
);


//* MIDI *//

// wrap midirecv and interpret values
// usage: while(msg.recv()) (msg.send())
function recv() local(received)
(
  //capture return value of midirecv and scope its args
  received = midirecv(m0, m1, m2, m3);
  received ? (
    this.offset = m0;
    // m1 = status byte, some 8 bit number;
    // shift away lowest 4 bits: 1111???? -> 1111
    this.statusHi = m1 >> 4;
    // mask top 4 bits: ????1010 & 00001111 -> 00001010
    this.statusLo = m1 & $~4;
    this.data1 = m2;
    this.data2 = m3;
  );
  // return 1 or 0 for while() evaluation;
  received;
);


function send()
(
  midisend(
    this.offset,
    // reconstruct status by shifting high bits to the left
    // 1111 -> 11110000
    ((this.statusHi << 4) + this.statusLo),
    this.data1,
    this.data2
  );
);


function isNoteOn()
(
  this.statusHi == 9;
);


function isNoteOff()
(
  this.statusHi == 8;
);


function note()
(
  this.data1;
);


//* TIME *//

function samplesPerBar() // samples per bar
(
  // ts_num ts_denoms in a bar (4 quarter notes)
  // tempo ts_denoms in a minute (120 quarter notes)
  // duration of 1 bar in minutes = ts_num / tempo -> 4/120 = 0.0333...
  // duration of 1 bar in seconds = ts_num * 60 / tempo -> 4*60/120 = 2
  // duration of 1 bar in samples = srate * ts_num * 60 / tempo -> 48000 * 2
  srate * ts_num * 60 / tempo;
);
