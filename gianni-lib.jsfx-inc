@init

//* MATH *//
function round(num)
(
  floor(num + 0.5);
);


function randInt(num)
(
  round(rand(num));
);


function mask(n)
(
  pow(2, n)-1;
);

// foo.readBits(6, 3) will read bits 7 thru 9 as if they were their own 3-bit integer
function readBits(offset, nBits)
(
  // foo = 1101111111
  // shifted right 6 bits = 1101
  // 1101 masked by 111 = 0101 = 5
  (this >> offset) & mask(nBits);
);

// foo.writeBits(6, 3, 2) will write the number 2 into bits 7 thru 9
// (num must fit in numBits else good luck using this as intended)
function writeBits(offset, nBits, num)
(
  // subtract whatever value is in those bits
  // 1XXX111111 -= (XXX << 6) = 1000111111
  this -= this.readBits(offset, nBits) << offset;
  // add num back into that n bit hole
  // 1000111111 + (2 << 6) = 1010111111
  this += num << offset;
  // -> foo.readBits(3, 6) = 010 = 2
);


// * ARRAYS *//

//tenSizeArray.arrayInit(10); 
function arrayInit(size) local (index)
(
  index = _nextArrayIdx; // _nextArrayIdx will be globally initialized at 0 on first call;
  _nextArrayIdx = index + size; // set up index for next call
  this = index;
  this.size = size;
  this.len = 0;
);

// tenSizeArray.push(foo)
function push(value)
(
  this.len < this.size && (
    this[this.len] = value;
    this.len += 1;
  );
);

// tenSizeArray.pop()
function pop() local (return)
(
  this.len > 0 && (
    this.len -=1;
    return = this[this.len];
  );
  return; // ðŸ˜’ local vars persist, so popping from an empty array will reliably produce spurious values.
);        // there's no return value we could use to reliably indicate "was empty" so we won't bother reassigning.

function find(value) local (return, i)
(
  return = -1;
  while ((return == -1) && (i < this.len))
  (
    value == this[i] && return = i;
    i += 1;
  );
  return; // nb. value may exist at more than 1 index, this will only return the first.
);

//* MIDI *//

// wrap midirecv and interpret values
// usage: while(msg.recv()) (msg.send())
function recv() local(received)
(
  //capture return value of midirecv and scope its args
  received = midirecv(m0, m1, m2, m3);
  received ? (
    this.offset = m0;
    // m1 = status byte, some 8 bit number;
    // shift away lowest 4 bits: 1111???? -> 1111
    this.statusHi = m1 >> 4;
    // mask top 4 bits: ????1010 & 00001111 -> 00001010
    this.statusLo = m1 & $~4;
    this.data1 = m2;
    this.data2 = m3;
  );
  // return 1 or 0 for while() evaluation;
  received;
);


function send()
(
  midisend(
    this.offset,
    // reconstruct status by shifting high bits to the left
    // 1111 -> 11110000
    ((this.statusHi << 4) + this.statusLo),
    this.data1,
    this.data2
  );
);


function isNoteOn()
(
  this.statusHi == 9;
);


function isNoteOff()
(
  this.statusHi == 8;
);


function note()
(
  this.data1;
);


//* TIME *//

function samplesPerBar() // nb. may be non-integer
(
  // ts_num ts_denoms in a bar (4 quarter notes)
  // tempo ts_denoms in a minute (120 quarter notes)
  // duration of 1 bar in minutes = ts_num / tempo -> 4/120 = 0.0333...
  // duration of 1 bar in seconds = 60 * ts_num / tempo -> 4*60/120 = 2
  // duration of 1 bar in samples = srate * 60 * ts_num / tempo) -> 48000 * 2
  srate * ts_num * 60 / tempo;
);
