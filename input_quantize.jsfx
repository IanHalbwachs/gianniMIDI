desc: gianniMIDI live input quantize

in_pin:none
out_pin:none

slider1:16<1,16,1>quantize interval (bar/n)

slider2:0<0,2,1{don't (good for one-shots),unquantized (note on & offs received within the same interval will not play),quantized (note on & offs received within the same interval will not play)}>send note offs 

import gianni-lib.jsfx-inc

@init

// msg methods
function enqNoteOn()
(
  onQueue.push(this.toBits());
);


function cancelNoteOn(i)
(
  onQueue[i] = 0;
);


function enqNoteOff()
(
  offQueue.push(this.toBits());
);


function posInQueue() local (i, pos, comp)
( 
  pos = -1;
  i = 0;
  while((pos == -1) && (i < onQueue.length))
  (
    comp = onQueue[i];
    comp.parseBits();
    (this.statusLo == comp.statusLo) && (this.data1 == comp.data1) && pos = i;
    i += 1;
  );
  pos;
);

// global methods
function dequeue(queue*)
(
  while(queue.length > 0)
  (
    _m = queue.pop();
    _m.parseBits();
    _m.send();
  );
);

onQueue.arrayInit(128);
offQueue.arrayInit(128);

// we will need a clock if we want this to work when stopped
// TODO: use beatpos when playing, handoff to clock on stop / reset on start
period = 0;
sCount = 0;


@serialize

period = samplesPerBar() / slider1;


@slider

period = samplesPerBar() / slider1;


@sample 

while (msg.recv())   
(
  handled = 0;
  msg.isNoteOn() &&
  (
    (msg.posInQueue() < 0) && msg.enqNoteOn();
    handled = 1;
  );
  msg.isNoteOff() &&
  (
    slider2 > 0 && (
      _pos = msg.posInQueue();
      _pos > -1 ? cancelNoteOn(_pos) : (slider2 == 1 ? msg.send() : msg.enqNoteOff());
    );
    handled = 1;
  );
  !handled && msg.send();
);
sCount += 1;
sCount >= period && sCount = 0;
sCount == 0 && (
  slider2 == 2 && dequeue(offQueue);
  dequeue(onQueue);
);
